import tkinter as tk


# val = str(input("values:")) # For manual insertion of a configuration
hardcore = "8 0 0 0 0 2 0 0 0 0 0 4 0 0 0 0 9 0 9 0 0 0 5 6 8 0 0 5 0 0 2 0 0 0 0 0 0 0 3 0 7 5 0 0 6 0 0 0 4 0 0 7 0 0 0 1 0 0 0 0 0 0 3 0 0 0 7 0 0 0 0 0 4 0 0 0 8 9 6 0 0"
val2 = "1 0 4 9 0 2 0 0 6 9 0 0 1 0 4 5 2 0 2 8 0 0 3 0 9 0 1 3 0 6 4 7 0 8 0 0 0 4 0 8 2 5 0 3 0 5 0 8 0 0 0 1 7 4 0 5 2 7 0 0 4 9 0 0 1 0 0 9 3 0 6 8 0 3 9 0 4 8 0 0 5"
val = "3 0 6 5 0 8 4 0 0 5 2 0 0 0 0 0 0 0 0 8 7 0 0 0 0 3 1 0 0 3 0 1 0 0 8 0 9 0 0 8 6 3 0 0 5 0 5 0 0 9 0 6 0 0 1 3 0 0 0 0 2 5 0 0 0 0 0 0 0 0 7 4 0 0 5 2 0 6 3 0 0"
valList = hardcore.split(" ")


class sudoku:
    def __init__(self, values):
        self.__values = values
        self.__grid = [[0 for i in range(9)] for j in range(9)]
        self.__squares = [[0 for x in range(3)] for y in range(3)]
        self.__generateGrid()
        self.__generateSquares()

    def printGrid(self):                    # prints the grid
        for i in range(len(self.__grid)):
            print(self.__grid[i])

    def printSquares(self):                 # prints the squares
        for i in range(3):
            for j in range(3):
                print(self.__squares[i][j])
            print("\n")

    def editGrid(self, x, y, value):        # tool to manually change values from the grid
        self.__grid[x][y] = value

    def __generateGrid(self):               # transforms the values into a matrix
        k = 0
        for i in range(9):
            for j in range(9):
                self.__grid[i][j] = int(self.__values[k])
                k += 1

    def __generateSquares(self):            # transforms the values into 9 3x3 grids
        for i in range(3):
            for j in range(3):
                square = [[0 for x in range(3)] for y in range(3)]
                for k in range(3):
                    for l in range(3):
                        square[k][l] = self.__grid[i * 3 + k][j * 3 + l]
                self.__squares[i][j] = square

    def __isSolved(self):                   # checks if the sudoku has been solved
        for i in range(len(self.__grid)):
            for j in range(len(self.__grid[i])):
                if (
                    self.__grid[i][j] == 0
                ):                          # if it finds and zeros in the grid, returns False
                    return False

        return True

    def __checkVertical(
        self, x, y, sety=set()
    ):                                      # checks for values in the same colomn as the target position
        for i in range(9):
            if self.__grid[i][y] != 0 and i != x:
                sety.add(self.__grid[i][y])

        return sety

    def __checkHorizontal(
        self, x, y, setx=set()
    ):                                      # checks for values in the same line as the target position
        setx.clear()                        # clears the values from the last checked position
        for i in range(9):
            if self.__grid[x][i] != 0 and i != y:
                setx.add(self.__grid[x][i])

        return setx

    def __checkSquare(
        self, x, y, sets=set()
    ):                                      # checks for values in the same square as the target position
        a = int(x / 3)
        b = int(y / 3)
        square = self.__squares[a][b]
        for i in range(3):
            for j in range(3):
                if square[i][j] != 0:
                    sets.add(square[i][j])

        return sets

    def check(
        self, x, y
    ):                                      # combines all the checking methods and returns the values that are NOT in the resulting set
        self.__generateSquares()            # They all use a shared set
        H = self.__checkHorizontal(x, y)    # generated by the first called method
        V = self.__checkVertical(x, y, H)   # in this case __checkHorizontal
        S = self.__checkSquare(x, y, V)
        validValues = []
        for i in range(1, 10):
            if i not in S:
                validValues.append(i)

        return validValues

    def solve(self, i=0, j=0):                  # backtracking method to solve the puzzle
        if j == 9:                              # changes row if the current one has been completed
            i += 1
            j = 0

        if self.__isSolved():                   # checks if the puzzle has been solved
            return True

        if self.__grid[i][j] != 0:
                                                # skips positions that already have a number associated with it
            return self.solve(i, j + 1)

        values = self.check(i, j)               # calculates posible candidates for (i, j)
        for val in values:
            self.__grid[i][j] = val             # asserts the value

            if self.solve(i, j + 1) == True:    # checks if the next one is possible
                return True

            self.__grid[i][j] = 0               # assertion was wrong, so we remove the value

        return False

s = sudoku(valList)                 # Driver code

if s.solve() == True:
    s.printGrid()
else:
    print("Could not solve game")




