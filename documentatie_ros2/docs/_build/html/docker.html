
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Installing Docker Desktop &#8212; Documentatie ros2 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/groundwork.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="VMBox" href="VMBox.html" />
    <link rel="prev" title="Basic talker tutorial" href="step1_ros.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="VMBox.html" title="VMBox"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="step1_ros.html" title="Basic talker tutorial"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentatie ros2 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Installing Docker Desktop</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="installing-docker-desktop">
<h1>Installing Docker Desktop<a class="headerlink" href="#installing-docker-desktop" title="Permalink to this heading">¶</a></h1>
<section id="what-is-docker">
<h2>What is Docker?<a class="headerlink" href="#what-is-docker" title="Permalink to this heading">¶</a></h2>
<p>Wikipedia defines Docker as an open-source project that automates the deployment of software applications inside containers by providing an additional layer of abstraction and automation of OS-level virtualization on Linux.</p>
<p>Wow! That’s a mouthful. In simpler words, Docker is a tool that allows developers, sys-admins etc. to easily deploy their applications in a sandbox (called containers) to run on the host operating system i.e. Linux. The key benefit of Docker is that it allows users to package an application with all of its dependencies into a standardized unit for software development. Unlike virtual machines, containers do not have high overhead and hence enable more efficient usage of the underlying system and resources.</p>
</section>
<section id="what-are-containers">
<h2>What are containers?<a class="headerlink" href="#what-are-containers" title="Permalink to this heading">¶</a></h2>
<p>The industry standard today is to use Virtual Machines (VMs) to run software applications. VMs run applications inside a guest Operating System, which runs on virtual hardware powered by the server’s host OS.</p>
<p>VMs are great at providing full process isolation for applications: there are very few ways a problem in the host operating system can affect the software running in the guest operating system, and vice-versa. But this isolation comes at great cost — the computational overhead spent virtualizing hardware for a guest OS to use is substantial.</p>
<p>Containers take a different approach: by leveraging the low-level mechanics of the host operating system, containers provide most of the isolation of virtual machines at a fraction of the computing power.</p>
</section>
<section id="why-use-containers">
<h2>Why use containers?<a class="headerlink" href="#why-use-containers" title="Permalink to this heading">¶</a></h2>
<p>Containers offer a logical packaging mechanism in which applications can be abstracted from the environment in which they actually run. This decoupling allows container-based applications to be deployed easily and consistently, regardless of whether the target environment is a private data center, the public cloud, or even a developer’s personal laptop. This gives developers the ability to create predictable environments that are isolated from the rest of the applications and can be run anywhere.</p>
<p>From an operations standpoint, apart from portability containers also give more granular control over resources giving your infrastructure improved efficiency which can result in better utilization of your compute resources.</p>
<p>Due to these benefits, containers (&amp; Docker) have seen widespread adoption. Companies like Google, Facebook, Netflix and Salesforce leverage containers to make large engineering teams more productive and to improve utilization of compute resources. In fact, Google credited containers for eliminating the need for an entire data center.</p>
</section>
<section id="setting-up-your-computer">
<h2>Setting up your computer<a class="headerlink" href="#setting-up-your-computer" title="Permalink to this heading">¶</a></h2>
<p>First go to the official Docker Desktop page and download it:</p>
<p><a class="reference external" href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a></p>
<p>After installation test your Docker installation by running the following:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>run<span class="w"> </span>hello-world
</pre></div>
</div>
<p>It should display this message:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Hello from Docker.</span>
<span class="go">This message shows that your installation appears to be working correctly.</span>
<span class="go">...</span>
</pre></div>
</div>
<p>If you get an error:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">docker: error during connect: this error may indicate that the docker daemon is not running:</span>
<span class="go">Post &quot;&lt;http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.24/containers/create&gt;&quot;:</span>
<span class="go">open //./pipe/docker_engine: The system cannot find the file specified.</span>
<span class="go">See &#39;docker run --help&#39;.</span>
</pre></div>
</div>
<p>Make sure that you are running Docker.</p>
</section>
</section>
<section id="hello-world">
<h1>HELLO WORLD<a class="headerlink" href="#hello-world" title="Permalink to this heading">¶</a></h1>
<section id="playing-with-busybox">
<h2>Playing with Busybox<a class="headerlink" href="#playing-with-busybox" title="Permalink to this heading">¶</a></h2>
<p>Now that we have everything setup, it’s time to get our hands dirty. In this section, we are going to run a Busybox container on our system and get a taste of the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> command.</p>
<p>To get started, let’s run the following in our terminal:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>pull<span class="w"> </span>busybox
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>Depending on how you’ve installed docker on your system, you might see a permission denied error after running the above command. If you’re on a Mac, make sure the Docker engine is running. If you’re on Linux, then prefix your docker commands with sudo. Alternatively, you can create a docker group to get rid of this issue.</cite></p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">pull</span></code> command fetches the busybox image from the Docker registry and saves it to our system. You can use the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">images</span></code> command to see a list of all images on your system.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>images
<span class="go">REPOSITORY              TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span>
<span class="go">busybox                 latest              c51f86c28340        4 weeks ago         1.109 MB</span>
</pre></div>
</div>
</section>
<section id="docker-run">
<h2>Docker Run<a class="headerlink" href="#docker-run" title="Permalink to this heading">¶</a></h2>
<p>Great! Let’s now run a Docker container based on this image. To do that we are going to use the almighty <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> command.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>run<span class="w"> </span>busybox
<span class="gp">$</span>
</pre></div>
</div>
<p>Wait, nothing happened! Is that a bug? Well, no. Behind the scenes, a lot of stuff happened. When you call <code class="docutils literal notranslate"><span class="pre">run</span></code>, the Docker client finds the image (busybox in this case), loads up the container and then runs a command in that container. When we run <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> busybox, we didn’t provide a command, so the container booted up, ran an empty command and then exited. Well, yeah - kind of a bummer. Let’s try something more exciting.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>run<span class="w"> </span>busybox<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;hello from busybox&quot;</span>
<span class="go">hello from busybox</span>
</pre></div>
</div>
<p>Nice - finally we see some output. In this case, the Docker client dutifully ran the <code class="docutils literal notranslate"><span class="pre">echo</span></code> command in our busybox container and then exited it. If you’ve noticed, all of that happened pretty quickly. Imagine booting up a virtual machine, running a command and then killing it. Now you know why they say containers are fast! Ok, now it’s time to see the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code> command. The <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code> command shows you all containers that are currently running.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>ps
<span class="go">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span>
</pre></div>
</div>
<p>Since no containers are running, we see a blank line. Let’s try a more useful variant: <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span> <span class="pre">-a</span></code></p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>ps<span class="w"> </span>-a
<span class="go">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span>
<span class="go">305297d7a235        busybox             &quot;uptime&quot;            11 minutes ago      Exited (0) 11 minutes ago                       distracted_goldstine</span>
<span class="go">ff0a5c3750b9        busybox             &quot;sh&quot;                12 minutes ago      Exited (0) 12 minutes ago                       elated_ramanujan</span>
<span class="go">14e5bd11d164        hello-world         &quot;/hello&quot;            2 minutes ago       Exited (0) 2 minutes ago                        thirsty_euclid</span>
</pre></div>
</div>
<p>So what we see above is a list of all containers that we ran. Do notice that the STATUS column shows that these containers exited a few minutes ago.</p>
<p>You’re probably wondering if there is a way to run more than just one command in a container. Let’s try that now:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>run<span class="w"> </span>-it<span class="w"> </span>busybox<span class="w"> </span>sh
<span class="go">/ # ls</span>
<span class="go">bin   dev   etc   home  proc  root  sys   tmp   usr   var</span>
<span class="go">/ # uptime</span>
<span class="go"> 05:45:21 up  5:58,  0 users,  load average: 0.00, 0.01, 0.04</span>
</pre></div>
</div>
<p>Running the <code class="docutils literal notranslate"><span class="pre">run</span></code> command with the -it flags attaches us to an interactive tty in the container. Now we can run as many commands in the container as we want. Take some time to run your favorite commands.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Danger Zone: If you’re feeling particularly adventurous you can try rm -rf bin in the container. Make sure you run this command in the container and not in your laptop/desktop. Doing this will make any other commands like ls, uptime not work. Once everything stops working, you can exit the container (type exit and press Enter) and then start it up again with the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> -it busybox sh command. Since Docker creates a new container every time, everything should start working again.</p>
</div>
<p>That concludes a whirlwind tour of the mighty <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> command, which would most likely be the command you’ll use most often. It makes sense to spend some time getting comfortable with it. To find out more about run, use <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> –help to see a list of all flags it supports. As we proceed further, we’ll see a few more variants of <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code>.</p>
<p>Before we move ahead though, let’s quickly talk about deleting containers. We saw above that we can still see remnants of the container even after we’ve exited by running <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span> <span class="pre">-a</span></code>. Throughout this tutorial, you’ll run <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> multiple times and leaving stray containers will eat up disk space. Hence, as a rule of thumb, I clean up containers once I’m done with them. To do that, you can run the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">rm</span></code> command. Just copy the container IDs from above and paste them alongside the command.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>rm<span class="w"> </span>305297d7a235<span class="w"> </span>ff0a5c3750b9
<span class="go">305297d7a235</span>
<span class="go">ff0a5c3750b9</span>
</pre></div>
</div>
<p>On deletion, you should see the IDs echoed back to you. If you have a bunch of containers to delete in one go, copy-pasting IDs can be tedious. In that case, you can simply run -</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>rm<span class="w"> </span><span class="k">$(</span>docker<span class="w"> </span>ps<span class="w"> </span>-a<span class="w"> </span>-q<span class="w"> </span>-f<span class="w"> </span><span class="nv">status</span><span class="o">=</span>exited<span class="k">)</span>
</pre></div>
</div>
<p>This command deletes all containers that have a status of <code class="docutils literal notranslate"><span class="pre">exited</span></code>. In case you’re wondering, the <code class="docutils literal notranslate"><span class="pre">-q</span></code> flag, only returns the numeric IDs and <code class="docutils literal notranslate"><span class="pre">-f</span></code> filters output based on conditions provided. One last thing that’ll be useful is the <code class="docutils literal notranslate"><span class="pre">--rm</span></code> flag that can be passed to <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> which automatically deletes the container once it’s exited from. For one off docker runs, <code class="docutils literal notranslate"><span class="pre">--rm</span></code> flag is very useful.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In later versions of Docker, the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">prune</span></code> command can be used to achieve the same effect.</p>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>container<span class="w"> </span>prune
<span class="go">WARNING! This will remove all stopped containers.</span>
<span class="go">Are you sure you want to continue? [y/N] y</span>
<span class="go">Deleted Containers:</span>
<span class="go">4a7f7eebae0f63178aff7eb0aa39f0627a203ab2df258c1a00b456cf20063</span>
<span class="go">f98f9c2aa1eaf727e4ec9c0283bcaa4762fbdba7f26191f26c97f64090360</span>

<span class="go">Total reclaimed space: 212 B</span>
</pre></div>
</div>
<p>Lastly, you can also delete images that you no longer need by running <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">rmi</span></code>.</p>
</section>
<section id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this heading">¶</a></h2>
<p>In the last section, we used a lot of Docker-specific jargon which might be confusing to some. So before we go further, let me clarify some terminology that is used frequently in the Docker ecosystem.</p>
<blockquote>
<div><ul class="simple">
<li><p>Images - The blueprints of our application which form the basis of containers. In the demo above, we used the docker pull command to download the busybox image.</p></li>
<li><p>Containers - Created from Docker images and run the actual application. We create a container using <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> which we did using the busybox image that we downloaded. A list of running containers can be seen using the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code> command.</p></li>
<li><p>Docker Daemon - The background service running on the host that manages building, running and distributing Docker containers. The daemon is the process that runs in the operating system which clients talk to.</p></li>
<li><p>Docker Client - The command line tool that allows the user to interact with the daemon. More generally, there can be other forms of clients too - such as Kitematic which provide a GUI to the users.</p></li>
<li><p>Docker Hub - A registry of Docker images. You can think of the registry as a directory of all available Docker images. If required, one can host their own Docker registries and can use them for pulling images.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="webapps-with-docker">
<h1>WEBAPPS WITH DOCKER<a class="headerlink" href="#webapps-with-docker" title="Permalink to this heading">¶</a></h1>
<p>Great! So we have now looked at <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code>, played with a Docker container and also got a hang of some terminology.
Our First Image
<strong>************</strong></p>
<p>Now that we have a better understanding of images, it’s time to create our own. Our goal in this section will be to create an image that sandboxes a simple Flask application. For the purposes of this workshop, I’ve already created a fun little Flask app that displays a random cat <code class="docutils literal notranslate"><span class="pre">.gif</span></code> every time it is loaded - because you know, who doesn’t like cats? If you haven’t already, please go ahead and clone the repository locally like so -</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/prakhar1989/docker-curriculum.git
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>docker-curriculum/flask-app
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should be cloned on the machine where you are running the docker commands and not inside a docker container.</p>
</div>
<p>The next step now is to create an image with this web app. As mentioned above, all user images are based on a base image. Since our application is written in Python, the base image we’re going to use will be Python 3.</p>
<section id="dockerfile">
<h2>Dockerfile<a class="headerlink" href="#dockerfile" title="Permalink to this heading">¶</a></h2>
<p>A Dockerfile is a simple text file that contains a list of commands that the Docker client calls while creating an image. It’s a simple way to automate the image creation process. The best part is that the commands you write in a Dockerfile are almost identical to their equivalent Linux commands. This means you don’t really have to learn new syntax to create your own dockerfiles.</p>
<p>The application directory does contain a Dockerfile but since we’re doing this for the first time, we’ll create one from scratch. To start, create a new blank file in our favorite text-editor and save it in the same folder as the flask app by the name of <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>.</p>
<p>We start with specifying our base image. Use the <code class="docutils literal notranslate"><span class="pre">FROM</span></code> keyword to do that -</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">python</span><span class="p">:</span><span class="mf">3.8</span>
</pre></div>
</div>
<p>The next step usually is to write the commands of copying the files and installing the dependencies. First, we set a working directory and then copy all the files for our app.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># set a directory for the app</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>

<span class="c1"># copy all the files to the container</span>
<span class="n">COPY</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
<p>Now, that we have the files, we can install the dependencies.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># install dependencies</span>
<span class="n">RUN</span> <span class="n">pip</span> <span class="n">install</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span><span class="o">-</span><span class="nb">dir</span> <span class="o">-</span><span class="n">r</span> <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>The next thing we need to specify is the port number that needs to be exposed. Since our flask app is running on port <code class="docutils literal notranslate"><span class="pre">5000</span></code>, that’s what we’ll indicate.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">EXPOSE</span> <span class="mi">5000</span>
</pre></div>
</div>
<p>The last step is to write the command for running the application, which is simply - <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">./app.py</span></code>. We use the CMD command to do that -</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;python&quot;</span><span class="p">,</span> <span class="s2">&quot;./app.py&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The primary purpose of <code class="docutils literal notranslate"><span class="pre">CMD</span></code> is to tell the container which command it should run when it is started. With that, our <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> is now ready. This is how it looks -</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">python</span><span class="p">:</span><span class="mf">3.8</span>

<span class="c1"># set a directory for the app</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>

<span class="c1"># copy all the files to the container</span>
<span class="n">COPY</span> <span class="o">.</span> <span class="o">.</span>

<span class="c1"># install dependencies</span>
<span class="n">RUN</span> <span class="n">pip</span> <span class="n">install</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span><span class="o">-</span><span class="nb">dir</span> <span class="o">-</span><span class="n">r</span> <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>

<span class="c1"># define the port number the container should expose</span>
<span class="n">EXPOSE</span> <span class="mi">5000</span>

<span class="c1"># run the command</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;python&quot;</span><span class="p">,</span> <span class="s2">&quot;./app.py&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Now that we have our <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>, we can build our image. The <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> command does the heavy-lifting of creating a Docker image from a <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>.</p>
<p>The section below shows you the output of running the same. Before you run the command yourself (don’t forget the period), make sure to replace my username with yours. This username should be the same one you created when you registered on Docker hub. If you haven’t done that yet, please go ahead and create an account. The <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> command is quite simple - it takes an optional tag name with <code class="docutils literal notranslate"><span class="pre">-t</span></code> and a location of the directory containing the <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>yourusername/catnip<span class="w"> </span>.
<span class="go">Sending build context to Docker daemon 8.704 kB</span>
<span class="go">Step 1 : FROM python:3.8</span>
<span class="gp"># </span>Executing<span class="w"> </span><span class="m">3</span><span class="w"> </span>build<span class="w"> </span>triggers...
<span class="go">Step 1 : COPY requirements.txt /usr/src/app/</span>
<span class="go"> ---&gt; Using cache</span>
<span class="go">Step 1 : RUN pip install --no-cache-dir -r requirements.txt</span>
<span class="go"> ---&gt; Using cache</span>
<span class="go">Step 1 : COPY . /usr/src/app</span>
<span class="go"> ---&gt; 1d61f639ef9e</span>
<span class="go">Removing intermediate container 4de6ddf5528c</span>
<span class="go">Step 2 : EXPOSE 5000</span>
<span class="go"> ---&gt; Running in 12cfcf6d67ee</span>
<span class="go"> ---&gt; f423c2f179d1</span>
<span class="go">Removing intermediate container 12cfcf6d67ee</span>
<span class="go">Step 3 : CMD python ./app.py</span>
<span class="go"> ---&gt; Running in f01401a5ace9</span>
<span class="go"> ---&gt; 13e87ed1fbc2</span>
<span class="go">Removing intermediate container f01401a5ace9</span>
<span class="go">Successfully built 13e87ed1fbc2</span>
</pre></div>
</div>
<p>If you don’t have the <code class="docutils literal notranslate"><span class="pre">python:3.8</span></code> image, the client will first pull the image and then create your image. Hence, your output from running the command will look different from mine. If everything went well, your image should be ready! Run <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">images</span></code> and see if your image shows.</p>
<p>The last step in this section is to run the image and see if it actually works (replacing my username with yours).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>run<span class="w"> </span>-p<span class="w"> </span><span class="m">8888</span>:5000<span class="w"> </span>yourusername/catnip
<span class="go"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span>
</pre></div>
</div>
<p>The command we just ran used port 5000 for the server inside the container and exposed this externally on port 8888. Head over to the URL with port 8888, where your app should be live.</p>
<p>Congratulations! You have successfully created your first docker image.</p>
<p>Docker Compose</p>
<p>Till now we’ve spent all our time exploring the Docker client. In the Docker ecosystem, however, there are a bunch of other open-source tools which play very nicely with Docker. A few of them are -</p>
<blockquote>
<div><ul class="simple">
<li><p>Docker Machine - Create Docker hosts on your computer, on cloud providers, and inside your own data center</p></li>
<li><p>Docker Compose - A tool for defining and running multi-container Docker applications.</p></li>
<li><p>Docker Swarm - A native clustering solution for Docker</p></li>
<li><p>Kubernetes - Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.</p></li>
</ul>
</div></blockquote>
<p>In this section, we are going to look at one of these tools, Docker Compose, and see how it can make dealing with multi-container apps easier.</p>
<p>So what is Compose used for? Compose is a tool that is used for defining and running multi-container Docker apps in an easy way. It provides a configuration file called <code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> that can be used to bring up an application and the suite of services it depends on with just one command. Compose works in all environments: production, staging, development, testing, as well as CI workflows, although Compose is ideal for development and testing environments.</p>
<p>Let’s see if we can create a <code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file.</p>
<p>The first step, however, is to install Docker Compose. If you’re running Windows or Mac, Docker Compose is already installed as it comes in the Docker Toolbox. Linux users can easily get their hands on Docker Compose by following the instructions on the docs. Since Compose is written in Python, you can also simply do <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">docker-compose</span></code>. Test your installation with -</p>
<p>$ docker-compose –version
docker-compose version 1.21.2, build a133471
Now that we have it installed, we can jump on the next step i.e. the Docker Compose file docker-compose.yml. The syntax for YAML is quite simple and the repo already contains the docker-compose file that we’ll be using.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">version: &quot;3&quot;</span>
<span class="go">services:</span>
<span class="go">  es:</span>
<span class="go">    image: docker.elastic.co/elasticsearch/elasticsearch:6.3.2</span>
<span class="go">    container_name: es</span>
<span class="go">    environment:</span>
<span class="go">      - discovery.type=single-node</span>
<span class="go">    ports:</span>
<span class="go">      - 9200:9200</span>
<span class="go">    volumes:</span>
<span class="go">      - esdata1:/usr/share/elasticsearch/data</span>
<span class="go">  web:</span>
<span class="go">    image: yourusername/foodtrucks-web</span>
<span class="go">    command: python3 app.py</span>
<span class="go">    depends_on:</span>
<span class="go">      - es</span>
<span class="go">    ports:</span>
<span class="go">      - 5000:5000</span>
<span class="go">    volumes:</span>
<span class="go">      - ./flask-app:/opt/flask-app</span>
<span class="go">volumes:</span>
<span class="go">  esdata1:</span>
<span class="go">    driver: local</span>
</pre></div>
</div>
<p>Let me breakdown what the file above means. At the parent level, we define the names of our services - es and web. The image parameter is always required, and for each service that we want Docker to run, we can add additional parameters. For es, we just refer to the elasticsearch image available on Elastic registry. For our Flask app, we refer to the image that we built at the beginning of this section.</p>
<p>Other parameters such as command and ports provide more information about the container. The volumes parameter specifies a mount point in our web container where the code will reside. This is purely optional and is useful if you need access to logs, etc. We’ll later see how this can be useful during development. Refer to the online reference to learn more about the parameters this file supports. We also add volumes for the es container so that the data we load persists between restarts. We also specify depends_on, which tells docker to start the es container before web. You can read more about it on docker compose docs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You must be inside the directory with the docker-compose.yml file in order to execute most Compose commands.</p>
</div>
<p>Great! Now the file is ready, let’s see <code class="docutils literal notranslate"><span class="pre">docker-compose</span></code> in action. But before we start, we need to make sure the ports and names are free. So if you have the Flask and ES containers running, lets turn them off.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>stop<span class="w"> </span>es<span class="w"> </span>foodtrucks-web
<span class="go">es</span>
<span class="go">foodtrucks-web</span>

<span class="gp">$ </span>docker<span class="w"> </span>rm<span class="w"> </span>es<span class="w"> </span>foodtrucks-web
<span class="go">es</span>
<span class="go">foodtrucks-web</span>
</pre></div>
</div>
<p>Now we can run <code class="docutils literal notranslate"><span class="pre">docker-compose</span></code>. Navigate to the food trucks directory and run <code class="docutils literal notranslate"><span class="pre">docker-compose</span> <span class="pre">up</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker-compose<span class="w"> </span>up
<span class="go">Creating network &quot;foodtrucks_default&quot; with the default driver</span>
<span class="go">Creating foodtrucks_es_1</span>
<span class="go">Creating foodtrucks_web_1</span>
<span class="go">Attaching to foodtrucks_es_1, foodtrucks_web_1</span>
<span class="go">es_1  | [2016-01-11 03:43:50,300][INFO ][node                     ] [Comet] version[2.1.1], pid[1], build[40e2c53/2015-12-15T13:05:55Z]</span>
<span class="go">es_1  | [2016-01-11 03:43:50,307][INFO ][node                     ] [Comet] initializing ...</span>
<span class="go">es_1  | [2016-01-11 03:43:50,366][INFO ][plugins                  ] [Comet] loaded [], sites []</span>
<span class="go">es_1  | [2016-01-11 03:43:50,421][INFO ][env                      ] [Comet] using [1] data paths, mounts [[/usr/share/elasticsearch/data (/dev/sda1)]], net usable_space [16gb], net total_space [18.1gb], spins? [possibly], types [ext4]</span>
<span class="go">es_1  | [2016-01-11 03:43:52,626][INFO ][node                     ] [Comet] initialized</span>
<span class="go">es_1  | [2016-01-11 03:43:52,632][INFO ][node                     ] [Comet] starting ...</span>
<span class="go">es_1  | [2016-01-11 03:43:52,703][WARN ][common.network           ] [Comet] publish address: {0.0.0.0} is a wildcard address, falling back to first non-loopback: {172.17.0.2}</span>
<span class="go">es_1  | [2016-01-11 03:43:52,704][INFO ][transport                ] [Comet] publish_address {172.17.0.2:9300}, bound_addresses {[::]:9300}</span>
<span class="go">es_1  | [2016-01-11 03:43:52,721][INFO ][discovery                ] [Comet] elasticsearch/cEk4s7pdQ-evRc9MqS2wqw</span>
<span class="go">es_1  | [2016-01-11 03:43:55,785][INFO ][cluster.service          ] [Comet] new_master {Comet}{cEk4s7pdQ-evRc9MqS2wqw}{172.17.0.2}{172.17.0.2:9300}, reason: zen-disco-join(elected_as_master, [0] joins received)</span>
<span class="go">es_1  | [2016-01-11 03:43:55,818][WARN ][common.network           ] [Comet] publish address: {0.0.0.0} is a wildcard address, falling back to first non-loopback: {172.17.0.2}</span>
<span class="go">es_1  | [2016-01-11 03:43:55,819][INFO ][http                     ] [Comet] publish_address {172.17.0.2:9200}, bound_addresses {[::]:9200}</span>
<span class="go">es_1  | [2016-01-11 03:43:55,819][INFO ][node                     ] [Comet] started</span>
<span class="go">es_1  | [2016-01-11 03:43:55,826][INFO ][gateway                  ] [Comet] recovered [0] indices into cluster_state</span>
<span class="go">es_1  | [2016-01-11 03:44:01,825][INFO ][cluster.metadata         ] [Comet] [sfdata] creating index, cause [auto(index api)], templates [], shards [5]/[1], mappings [truck]</span>
<span class="go">es_1  | [2016-01-11 03:44:02,373][INFO ][cluster.metadata         ] [Comet] [sfdata] update_mapping [truck]</span>
<span class="go">es_1  | [2016-01-11 03:44:02,510][INFO ][cluster.metadata         ] [Comet] [sfdata] update_mapping [truck]</span>
<span class="go">es_1  | [2016-01-11 03:44:02,593][INFO ][cluster.metadata         ] [Comet] [sfdata] update_mapping [truck]</span>
<span class="go">es_1  | [2016-01-11 03:44:02,708][INFO ][cluster.metadata         ] [Comet] [sfdata] update_mapping [truck]</span>
<span class="go">es_1  | [2016-01-11 03:44:03,047][INFO ][cluster.metadata         ] [Comet] [sfdata] update_mapping [truck]</span>
<span class="go">web_1 |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span>
</pre></div>
</div>
<p>Head over to the IP to see your app live. That was amazing wasn’t it? Just a few lines of configuration and we have two Docker containers running successfully in unison. Let’s stop the services and re-run in detached mode.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">web_1 |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span>
<span class="go">Killing foodtrucks_web_1 ... done</span>
<span class="go">Killing foodtrucks_es_1 ... done</span>

<span class="gp">$ </span>docker-compose<span class="w"> </span>up<span class="w"> </span>-d
<span class="go">Creating es               ... done</span>
<span class="go">Creating foodtrucks_web_1 ... done</span>

<span class="gp">$ </span>docker-compose<span class="w"> </span>ps
<span class="go">      Name                    Command               State                Ports</span>
<span class="go">--------------------------------------------------------------------------------------------</span>
<span class="go">es                 /usr/local/bin/docker-entr ...   Up      0.0.0.0:9200-&gt;9200/tcp, 9300/tcp</span>
<span class="go">foodtrucks_web_1   python3 app.py                   Up      0.0.0.0:5000-&gt;5000/tcp</span>
</pre></div>
</div>
<p>Unsurprisingly, we can see both the containers running successfully. Where do the names come from? Those were created automatically by Compose. But does Compose also create the network automatically? Good question! Let’s find out.</p>
<p>First off, let us stop the services from running. We can always bring them back up in just one command. Data volumes will persist, so it’s possible to start the cluster again with the same data using docker-compose up. To destroy the cluster and the data volumes, just type <code class="docutils literal notranslate"><span class="pre">docker-compose</span> <span class="pre">down</span> <span class="pre">-v</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker-compose<span class="w"> </span>down<span class="w"> </span>-v
<span class="go">Stopping foodtrucks_web_1 ... done</span>
<span class="go">Stopping es               ... done</span>
<span class="go">Removing foodtrucks_web_1 ... done</span>
<span class="go">Removing es               ... done</span>
<span class="go">Removing network foodtrucks_default</span>
<span class="go">Removing volume foodtrucks_esdata1</span>
</pre></div>
</div>
<p>While we’re are at it, we’ll also remove the <code class="docutils literal notranslate"><span class="pre">foodtrucks</span></code> network that we created last time.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>network<span class="w"> </span>rm<span class="w"> </span>foodtrucks-net
<span class="gp">$ </span>docker<span class="w"> </span>network<span class="w"> </span>ls
<span class="go">NETWORK ID          NAME                 DRIVER              SCOPE</span>
<span class="go">c2c695315b3a        bridge               bridge              local</span>
<span class="go">a875bec5d6fd        host                 host                local</span>
<span class="go">ead0e804a67b        none                 null                local</span>
</pre></div>
</div>
<p>Great! Now that we have a clean slate, let’s re-run our services and see if Compose does its magic.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker-compose<span class="w"> </span>up<span class="w"> </span>-d
<span class="go">Recreating foodtrucks_es_1</span>
<span class="go">Recreating foodtrucks_web_1</span>

<span class="gp">$ </span>docker<span class="w"> </span>container<span class="w"> </span>ls
<span class="go">CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS                    NAMES</span>
<span class="go">f50bb33a3242        yourusername/foodtrucks-web  &quot;python3 app.py&quot;         14 seconds ago      Up 13 seconds       0.0.0.0:5000-&gt;5000/tcp   foodtrucks_web_1</span>
<span class="go">e299ceeb4caa        elasticsearch                &quot;/docker-entrypoint.s&quot;   14 seconds ago      Up 14 seconds       9200/tcp, 9300/tcp       foodtrucks_es_1</span>
</pre></div>
</div>
<p>So far, so good. Time to see if any networks were created.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>network<span class="w"> </span>ls
<span class="go">NETWORK ID          NAME                 DRIVER</span>
<span class="go">c2c695315b3a        bridge               bridge              local</span>
<span class="go">f3b80f381ed3        foodtrucks_default   bridge              local</span>
<span class="go">a875bec5d6fd        host                 host                local</span>
<span class="go">ead0e804a67b        none                 null                local</span>
</pre></div>
</div>
<p>You can see that compose went ahead and created a new network called <code class="docutils literal notranslate"><span class="pre">foodtrucks_default</span></code> and attached both the new services in that network so that each of these are discoverable to the other. Each container for a service joins the default network and is both reachable by other containers on that network, and discoverable by them at a hostname identical to the container name.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>docker<span class="w"> </span>ps
<span class="go">CONTAINER ID        IMAGE                                                 COMMAND                  CREATED              STATUS              PORTS                              NAMES</span>
<span class="go">8c6bb7e818ec        docker.elastic.co/elasticsearch/elasticsearch:6.3.2   &quot;/usr/local/bin/dock…&quot;   About a minute ago   Up About a minute   0.0.0.0:9200-&gt;9200/tcp, 9300/tcp   es</span>
<span class="go">7640cec7feb7        yourusername/foodtrucks-web                           &quot;python3 app.py&quot;         About a minute ago   Up About a minute   0.0.0.0:5000-&gt;5000/tcp             foodtrucks_web_1</span>

<span class="gp">$ </span>docker<span class="w"> </span>network<span class="w"> </span>inspect<span class="w"> </span>foodtrucks_default
<span class="go">[</span>
<span class="go">    {</span>
<span class="go">        &quot;Name&quot;: &quot;foodtrucks_default&quot;,</span>
<span class="go">        &quot;Id&quot;: &quot;f3b80f381ed3e03b3d5e605e42c4a576e32d38ba24399e963d7dad848b3b4fe7&quot;,</span>
<span class="go">        &quot;Created&quot;: &quot;2018-07-30T03:36:06.0384826Z&quot;,</span>
<span class="go">        &quot;Scope&quot;: &quot;local&quot;,</span>
<span class="go">        &quot;Driver&quot;: &quot;bridge&quot;,</span>
<span class="go">        &quot;EnableIPv6&quot;: false,</span>
<span class="go">        &quot;IPAM&quot;: {</span>
<span class="go">            &quot;Driver&quot;: &quot;default&quot;,</span>
<span class="go">            &quot;Options&quot;: null,</span>
<span class="go">            &quot;Config&quot;: [</span>
<span class="go">                {</span>
<span class="go">                    &quot;Subnet&quot;: &quot;172.19.0.0/16&quot;,</span>
<span class="go">                    &quot;Gateway&quot;: &quot;172.19.0.1&quot;</span>
<span class="go">                }</span>
<span class="go">            ]</span>
<span class="go">        },</span>
<span class="go">        &quot;Internal&quot;: false,</span>
<span class="go">        &quot;Attachable&quot;: true,</span>
<span class="go">        &quot;Ingress&quot;: false,</span>
<span class="go">        &quot;ConfigFrom&quot;: {</span>
<span class="go">            &quot;Network&quot;: &quot;&quot;</span>
<span class="go">        },</span>
<span class="go">        &quot;ConfigOnly&quot;: false,</span>
<span class="go">        &quot;Containers&quot;: {</span>
<span class="go">            &quot;7640cec7feb7f5615eaac376271a93fb8bab2ce54c7257256bf16716e05c65a5&quot;: {</span>
<span class="go">                &quot;Name&quot;: &quot;foodtrucks_web_1&quot;,</span>
<span class="go">                &quot;EndpointID&quot;: &quot;b1aa3e735402abafea3edfbba605eb4617f81d94f1b5f8fcc566a874660a0266&quot;,</span>
<span class="go">                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:02&quot;,</span>
<span class="go">                &quot;IPv4Address&quot;: &quot;172.19.0.2/16&quot;,</span>
<span class="go">                &quot;IPv6Address&quot;: &quot;&quot;</span>
<span class="go">            },</span>
<span class="go">            &quot;8c6bb7e818ec1f88c37f375c18f00beb030b31f4b10aee5a0952aad753314b57&quot;: {</span>
<span class="go">                &quot;Name&quot;: &quot;es&quot;,</span>
<span class="go">                &quot;EndpointID&quot;: &quot;649b3567d38e5e6f03fa6c004a4302508c14a5f2ac086ee6dcf13ddef936de7b&quot;,</span>
<span class="go">                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:03&quot;,</span>
<span class="go">                &quot;IPv4Address&quot;: &quot;172.19.0.3/16&quot;,</span>
<span class="go">                &quot;IPv6Address&quot;: &quot;&quot;</span>
<span class="go">            }</span>
<span class="go">        },</span>
<span class="go">        &quot;Options&quot;: {},</span>
<span class="go">        &quot;Labels&quot;: {</span>
<span class="go">            &quot;com.docker.compose.network&quot;: &quot;default&quot;,</span>
<span class="go">            &quot;com.docker.compose.project&quot;: &quot;foodtrucks&quot;,</span>
<span class="go">            &quot;com.docker.compose.version&quot;: &quot;1.21.2&quot;</span>
<span class="go">        }</span>
<span class="go">    }</span>
<span class="go">]</span>
</pre></div>
</div>
</section>
</section>
<section id="conclusion">
<h1>CONCLUSION<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h1>
<p>And that’s a wrap! After a long, exhaustive but fun tutorial you are now ready to take the container world by storm! If you followed along till the very end then you should definitely be proud of yourself. You learned how to setup Docker and how to run your own containers.</p>
<p>I hope that finishing this tutorial makes you more confident in your abilities to deal with servers. When you have an idea of building your next app, you can be sure that you’ll be able to get it in front of people with minimal effort.</p>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Installing Docker Desktop</a><ul>
<li><a class="reference internal" href="#what-is-docker">What is Docker?</a></li>
<li><a class="reference internal" href="#what-are-containers">What are containers?</a></li>
<li><a class="reference internal" href="#why-use-containers">Why use containers?</a></li>
<li><a class="reference internal" href="#setting-up-your-computer">Setting up your computer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hello-world">HELLO WORLD</a><ul>
<li><a class="reference internal" href="#playing-with-busybox">Playing with Busybox</a></li>
<li><a class="reference internal" href="#docker-run">Docker Run</a></li>
<li><a class="reference internal" href="#terminology">Terminology</a></li>
</ul>
</li>
<li><a class="reference internal" href="#webapps-with-docker">WEBAPPS WITH DOCKER</a><ul>
<li><a class="reference internal" href="#dockerfile">Dockerfile</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion">CONCLUSION</a></li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="step1_ros.html"
                          title="previous chapter">Basic talker tutorial</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="VMBox.html"
                          title="next chapter">VMBox</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/docker.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="VMBox.html" title="VMBox"
             >next</a> |</li>
        <li class="right" >
          <a href="step1_ros.html" title="Basic talker tutorial"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentatie ros2 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Installing Docker Desktop</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Alin Dulceanu, Eduard Cimpean.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.1.
    </div>
  </body>
</html>